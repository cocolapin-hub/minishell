ğŸ¤ RÃ©partition du travail

BinÃ´me A : Parsing
	Tokenizer (split en mots + opÃ©rateurs).
	Gestion quotes.
	Expansion $VAR et $?.
	Construction des structures de commande.

BinÃ´me B : ExÃ©cution
	Gestion des forks, execve, redirections, pipes.
	ImplÃ©mentation des builtins.
	Gestion des signaux.
___________________________________________________________


âœ… Conseils pratiques

Faites des branches Git par fonctionnalitÃ© (ex : parsing-quotes, exec-redirs),
	puis mergez via PR pour relire le code de lâ€™autre.
Commencez par un minishell minimal (juste exÃ©cuter ls avec execve), puis ajoutez petit Ã  petit.
Toujours tester sur bash pour comparer.
Notez vos choix de structures dans un README technique â†’ Ã§a vous Ã©vite dâ€™oublier pourquoi vous avez fait tel design.



ğŸ—“ï¸ AGENDA:

- mardi    	02/08: 15h on explique la struct de nos code srx! âœ…
- mercredi 	03/08:



___________________________________________________________


Lecture / Parsing des commandes
	Parsing = transformer la ligne de texte que lâ€™utilisateur tape en
		une structure de donnÃ©es que lâ€™exÃ©cution pourra utiliser.
	Lire la ligne avec readline.
	Lexer / tokenizer : lire la chaÃ®ne et produire une liste de tokens (mots, opÃ©rateurs |, <, >, >>, <<).
	Parser : transformer la liste de tokens en une liste de commandes (chaque commande a argv[], redirections, etc.).
	GÃ©rer les quotes (simples et doubles).
	ImplÃ©menter lâ€™expansion des variables dâ€™environnement ($VAR, $?).
	Construire une structure de commande (par ex. une liste chaÃ®nÃ©e de commandes avec leurs args,
		redirections, etc.).
	ğŸ‘‰ Une fois Ã§a fait, tu peux dÃ©jÃ  tester en affichant une "AST" simplifiÃ©e (commande + args + redirs).

3. ExÃ©cution des commandes
	Gestion du PATH â†’ trouver le binaire avec execve.
	Gestion des redirections (dup2, open).
	Gestion des pipes (chaÃ®ner avec pipe et fork).
	RÃ©cupÃ©rer le status pour $?.

4. Builtins
	Les intÃ©grer progressivement :
	Faciles : echo, pwd, env.
	Moyens : cd, export, unset.
	DÃ©licat : exit (bien gÃ©rer les cas dâ€™erreurs et la fin du programme).

	âš ï¸ Certains builtins doivent sâ€™exÃ©cuter sans fork (cd, export, unset, exit),
	 donc il faudra prÃ©voir une logique spÃ©ciale.

5. Gestion des signaux
	ctrl-C : affiche une nouvelle ligne + prompt.
	ctrl-D : quitte le shell.
	ctrl-\ : ignore.

	âš ï¸ Bien utiliser une seule variable globale pour stocker le signal.

6. Finalisation obligatoire
	Tests avec beaucoup de cas (quotes mal fermÃ©es, pipes multiples, heredoc, redirs combinÃ©es, etc.).
	Nettoyer les fuites mÃ©moire (valgrind).
	VÃ©rifier les signaux en interactif.

7. Bonus (si temps dispo)
	ImplÃ©menter && et || avec prioritÃ©s (donc parser une mini-grammaire).
	Wildcards * (glob sur fichiers du cwd).







	/*parsing*/

/* PARSING MINISHELL */

/// 1. Analyse de l'input
//    - RÃ©cupÃ©ration de la ligne de commande brute depuis l'utilisateur (readline)
//    - Gestion des cas particuliers :
//         - ligne vide â†’ ignorer et afficher prompt suivant
//         - EOF (Ctrl-D) â†’ quitter le shell
//         - caractÃ¨res spÃ©ciaux non valides ou non imprimables
//         - longueur excessive
//         - gestion des espaces et tabulations (hors quotes)

// 2. Tokenisation
//    - DÃ©coupage de la ligne en tokens (mots, opÃ©rateurs, redirections, pipes)
//    - Remplissage de la liste chaÃ®nÃ©e t_token
//        - type : WORD, PIPE, REDIR_IN, REDIR_OUT, REDIR_APPEND, REDIR_HEREDOC
//        - quote : Q_NONE, Q_SINGLE, Q_DOUBLE
//        - value : texte exact du token (avec quotes si prÃ©sentes)

// 3. Expansion et quote removal sur t_token
//    - Parcourir chaque token de type WORD
//    - Si quote != Q_SINGLE : remplacer les variables dâ€™environnement ($VAR, $?) par leur valeur
//    - Supprimer les quotes entourant le token

// 4. Analyse syntaxique
//    - VÃ©rification de la validitÃ© de la syntaxe :
//         - pas de pipe au dÃ©but ou Ã  la fin
//         - pas de double pipe consÃ©cutif
//         - chaque redirection est suivie dâ€™un token WORD valide
//    - Gestion des erreurs et affichage des messages utilisateurs

// 5. Construction de la structure interne
//    - Organisation des tokens en commandes (t_command)
//    - Pour chaque commande :
//         - args : tableau des mots de la commande (argv)
//         - redir : liste chaÃ®nÃ©e des redirections (<, >, >>, <<)
//         - next : commande suivante si pipe



// // avec "" ls -l -a " le parsing aura produit :
	cmd = "ls"
	args = {"ls", "-l", "-a", NULL} // le tableau doit etre termin par NULL et argv[0] = cmd
	find_in_path("ls", envp) doit renvoyer : /bin/ls
		// Pour Ã§a, il faut :
			Trouver la ligne PATH=... dans envp.
			DÃ©couper la valeur (/usr/local/bin:/usr/bin:/bin:...) avec ft_split (":").
			Pour chaque dossier, construire dir + "/" + cmd (/bin/ls, /usr/bin/ls, â€¦).
			VÃ©rifier avec access(path, X_OK) si le fichier existe et est exÃ©cutable.
			Retourner le premier trouvÃ©.