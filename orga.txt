ğŸ¤ RÃ©partition du travail

BinÃ´me A : Parsing
	Tokenizer (split en mots + opÃ©rateurs).
	Gestion quotes.
	Expansion $VAR et $?.
	Construction des structures de commande.

BinÃ´me B : ExÃ©cution
	Gestion des forks, execve, redirections, pipes.
	ImplÃ©mentation des builtins.
	Gestion des signaux.
___________________________________________________________


âœ… Conseils pratiques

Faites des branches Git par fonctionnalitÃ© (ex : parsing-quotes, exec-redirs),
	puis mergez via PR pour relire le code de lâ€™autre.
Commencez par un minishell minimal (juste exÃ©cuter ls avec execve), puis ajoutez petit Ã  petit.
Toujours tester sur bash pour comparer.
Notez vos choix de structures dans un README technique â†’ Ã§a vous Ã©vite dâ€™oublier pourquoi vous avez fait tel design.



ğŸ—“ï¸ AGENDA:

- mardi    	02/08: 15h on explique la struct de nos code srx! âœ…
- mercredi 	03/08: 



___________________________________________________________


Lecture / Parsing des commandes
	Parsing = transformer la ligne de texte que lâ€™utilisateur tape en
		une structure de donnÃ©es que lâ€™exÃ©cution pourra utiliser.
	Lire la ligne avec readline.
	Lexer / tokenizer : lire la chaÃ®ne et produire une liste de tokens (mots, opÃ©rateurs |, <, >, >>, <<).
	Parser : transformer la liste de tokens en une liste de commandes (chaque commande a argv[], redirections, etc.).
	GÃ©rer les quotes (simples et doubles).
	ImplÃ©menter lâ€™expansion des variables dâ€™environnement ($VAR, $?).
	Construire une structure de commande (par ex. une liste chaÃ®nÃ©e de commandes avec leurs args,
		redirections, etc.).
	ğŸ‘‰ Une fois Ã§a fait, tu peux dÃ©jÃ  tester en affichant une "AST" simplifiÃ©e (commande + args + redirs).

3. ExÃ©cution des commandes
	Gestion du PATH â†’ trouver le binaire avec execve.
	Gestion des redirections (dup2, open).
	Gestion des pipes (chaÃ®ner avec pipe et fork).
	RÃ©cupÃ©rer le status pour $?.

4. Builtins
	Les intÃ©grer progressivement :
	Faciles : echo, pwd, env.
	Moyens : cd, export, unset.
	DÃ©licat : exit (bien gÃ©rer les cas dâ€™erreurs et la fin du programme).

	âš ï¸ Certains builtins doivent sâ€™exÃ©cuter sans fork (cd, export, unset, exit),
	 donc il faudra prÃ©voir une logique spÃ©ciale.

5. Gestion des signaux
	ctrl-C : affiche une nouvelle ligne + prompt.
	ctrl-D : quitte le shell.
	ctrl-\ : ignore.

	âš ï¸ Bien utiliser une seule variable globale pour stocker le signal.

6. Finalisation obligatoire
	Tests avec beaucoup de cas (quotes mal fermÃ©es, pipes multiples, heredoc, redirs combinÃ©es, etc.).
	Nettoyer les fuites mÃ©moire (valgrind).
	VÃ©rifier les signaux en interactif.

7. Bonus (si temps dispo)
	ImplÃ©menter && et || avec prioritÃ©s (donc parser une mini-grammaire).
	Wildcards * (glob sur fichiers du cwd).