EXEMPLE avec expansion :	echo $HOME > $FILE

PARSING :					cmd->args = {"echo", "/home/claffut", NULL};
							cmd->elem (redir) = {type=REDIR_OUT, value="out.txt"};


CAS PARTICULIERS :

V	echo $ et "$"	:	affiche $ (parsing doit check si c'est avec echo ?)

V	echo "$BICHE"	:	affiche "" (chaine vide, pas supprimée car entre quotes) ( " = expans activée | ' = expans désactivée )

V	PATH= "a b c"
V	echo  $PATH		:	 a b c	(3 arguments)
V	echo "$PATH"	:	"a b c"	(1 argument)

V	cat << 	EOF
V	$USER			:	affiche claffut
	EOF

V	cat << 'EOF'
V	$USER			:	affiche $USER
v	EOF

x	FILE="out.txt"
x	echo coucou > $FILE		:	écrit dans out.txt

x	lol > $26CM		:	affiche ->	bash: $26CM: ambigous redirect

V	/bin/cd			:	bash: /bin/cd: No such file or directory
V	/bin/ls mdr		:	/bin/ls: cannot access 'mdr': No such file or directory ($? = 2)



V	exit lol		:	exit
						bash: exit: lol: numeric argument required ($? = 2)
V	exit 19			: 	suivi d'un echo $? donne : last_status = 19
V	exit long		:	bash: exit: 55555555555555555555555555555555555555555555555555555555: numeric argument required

V	$? / $?			:	0: command not found

V	CTRL-C			:	^C + nouvelle ligne avec nouveau prompt

V	CTRL-D			:	apres avoir écrit quelque chose : ne fait rien.		sinon quitte minishell

	cat (sans arg)
V	ctrl-c			:	interrompt la commande bloquante + ^C 					+ new prompt
V	ctrl-\			:	interrompt la commande bloquante + ^\Quit (core dumped) + new prompt
V	ctrl-d			:	interrompt la commande bloquante + new prompt (sans quitter minishell)

V	ls  "src/"		:	marche
v	ls '"src/"'		:	ls: cannot access '"src/"': No such file or directory

V	$ cat > | ls	:	bash: syntax error near unexpected token `|' 	(la parsing devrait donner un token REDIR_OUT null : redir->value == NULL)
V	$ cat >			: 	syntax error near unexpected token `newline'

V	minishell$ cat -e << eof
		> asdfasdf
		> asdfasdf
		> ^C
					:	minishell: heredoc: failed
					:	redirection: Bad file descriptor
					:	add echo $? 130 instead of 1

?	Message d erreur qui commence par bash: (exit ou > sans rien)


// //TO_DO :	// remove leaks
// 			// change le parsing cote cmd --> verifier que ca marche
// 			// handle quote the new way, discuss it with coco
// 			// regroup work

// // OPTI	:	//merge both ft_lstadd_back_cmd and ft_lstadd_back
// 			//merge both ft_lstlast_cmd and ft_lstlast

// // leaks:	//free cmd dans tokenisation?
// 			//leaks dans expansion corrige?





NEW:
			V	: que des espaces
			V	: !
			V	: :
			V	: <> new line syntax error near unexpected token `newline'
			V	: & - &&&&&   syntax error near unexpected token `&' or `&&'
			V	: ; - ;;;;    syntax error near unexpected token `;' or `;;'

				: / - ////////// - /././. - /.
				: syntax error -----> $?
				: $> echo      \n hola - \\ \\ - \\\\\\\\\\\
				: ""''echo hola""'''' que""'' tal""''
				: echo \$HOME
				: echo $UID
				: $> echo $HOME9 OK ---->  echo $9HOME / $0HOME /
				: $> echo $USER$var\$USER$USER\$USERtest$USER
				: echo $hola*
				: echo $""
				: echo $''HOME
				: $> echo "$HO"ME      --> pk je quitte minishell
				: echo ""$HOME - echo ''$HOME
				: echo "" $HOME - echo '' $HOME
				: echo $"HO""ME"
				: echo $ - echo $$ - echo $$$ - echo $$$$
				: $> echo $DONTEXIST Hola --> rajoute un espace quand variable est vide
				: echo ''hola''
				: echo "'"h'o'la"'" -->quitte minishell
				: "" echo "" hola"""""""""""" ""
				: echo ""hola -->ferme le terminal
				: echo hola""bonjour
				: "e"'c'ho 'b'"o"nj"o"'u'r
				: ""e"'c'ho 'b'"o"nj"o"'u'r"
				: $> echo "$DONTEXIST"Makefile
				: $HOME
				: $HOMEdskjhfkdshfsd
				: "$HOMEdskjhfkdshfsd"
				: $DONTEXIST
				: $LESS$VAR
--> ligne 211








