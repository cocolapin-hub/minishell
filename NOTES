EXEMPLE avec expansion :	echo $HOME > $FILE

PARSING :					cmd->args = {"echo", "/home/claffut", NULL};
							cmd->elem (redir) = {type=REDIR_OUT, value="out.txt"};


CAS PARTICULIERS :

	echo $ et "$"	:	affiche $ (parsing doit check si c'est avec echo ?)

	echo "$BICHE"	:	affiche "" (chaine vide, pas supprimée car entre quotes) ( " = expans activée | ' = expans désactivée )

	PATH= "a b c"
	echo  $PATH		:	 a b c	(3 arguments)
	echo "$PATH"	:	"a b c"	(1 argument)

	cat << 	EOF
	$USER			:	affiche claffut
	EOF

	cat << 'EOF'
	$USER			:	affiche $USER
	EOF

	FILE="out.txt"
	echo coucou > $FILE		:	écrit dans out.txt

	lol > $26CM		:	affiche ->	bash: $26CM: ambigous redirect

	/bin/cd			:	bash: /bin/cd: No such file or directory

	exit lol		:	exit
						bash: exit: lol: numeric argument required ($? = 2)
	exit 19			: suivi d'un echo $? donne : last_status = 19

	/bin/ls mdr		:	/bin/ls: cannot access 'mdr': No such file or directory ($? = 2)

	$? / $?			:	0: command not found

	CTRL-C			:	^C + nouvelle ligne avec nouveau prompt

	CTRL-D			:	apres avoir écrit quelque chose : ne fait rien.		sinon quitte minishell

	cat (sans arg)
	ctrl-c			:	interrompt la commande bloquante + ^C 					+ new prompt
	ctrl-\			:	interrompt la commande bloquante + ^\Quit (core dumped) + new prompt
	ctrl-d			:	interrompt la commande bloquante + new prompt (sans quitter minishell)

	ls  "src/"		:	marche
	ls '"src/"'		:	ls: cannot access '"src/"': No such file or directory

	$ cat > | ls	:	bash: syntax error near unexpected token `|' 	(la parsing devrait donner un token REDIR_OUT null : redir->value == NULL)







// //Priorite: // regroup work
// //TO_DO :	// remove leaks
// 			// change le parsing cote cmd --> verifier que ca marche
// 			// handle quote the new way, discuss it with coco
// 			// regroup work

// // OPTI	:	//merge both ft_lstadd_back_cmd and ft_lstadd_back
// 			//merge both ft_lstlast_cmd and ft_lstlast

// // leaks:	//free cmd dans tokenisation?
// 			//leaks dans expansion corrige?
